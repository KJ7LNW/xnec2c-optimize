#!/usr/bin/perl

# Keep this line, the whole config is a hash evaluated by do() because
# there are subs in the goal section.
{ 

# See PDL::Opt::Simplex::Simple for documentation on the simplex settings:
simplex => {
	ssize => 0.075,
	tolerance => 0.08
},

############################################################################
# NEC2 Geometry Variables

# These variables are optimized by simplex.  You can use these variables
# in the the function evaluated by Simplex, but the actual NEC2 geometry 
# implementation is elsewhere in perl (not in this config file).

# The idea is that you write a config file that defines a certain type of
# antenna, and then write an antenna script to run that config.  

# It used to be that a single geometry array had to be sliced into the
# different variables represented by the array.  This was non-intuitive
# and error-prone.  This new format simply specifies a datastructure of
# variables, values, and whether or not a value is enabled.  This means
# you can selectively disable a particular value and it will be excluded
# from optimization but still included when passed to the geometry (yagi)
# function.  Helper functions compile the state of this variable structure 
# into the vector array needed by simplex, and then extract values into
# a usable format to be passed to the geometry function.
#
# Basic format:  varname => { values => [...], enabled => [...] }, ...
#
# varname: the name of the variable being used.
# values:  an arrayref of values to be optimized
# enabled: 1 or 0: enabled a specific index to be optimized.
# Notes:
#      * If 'enabled' is undefined then all values are enabled.
#      * If 'enabled' is not an array, it can be a scalar 0 or 1
#        to indicate that all values are enabled/disabled.
#      * Enabling or disabling a variable may be useful in testing
#        certain geometry charactaristics during optimization.
# 

# yagi dimensions from https://www.qsl.net/dk7zb/PVC-Yagis/5-Ele-2m.htm
vars => {
	# Element lengths
	lengths => {
			values  => [ 1.038, 0.955, 0.959, 0.949, 0.935 ],
			enabled => [ 1,     1,     1,     1,     1 ]
		},

	# Spaces between elements:
	spaces => {
			values  => [ 0.000, 0.280, 0.15, 0.520, 0.53 ],
			enabled => [ 0,     1,     1,    1,     1 ]
		},

	wire_rad => {
			values => [ 0.002 ], # 2mm
			enabled => 0,
		},

	# must be odd!
	wire_segments => {
			values => [ 11 ],
			enabled => 0,
		}
},


############################################################################
# NEC2 Geometry

# This function takes a $vars as passed to f() by PDL::Opt::Simplex::Simple
# in the simplified format.  (The vars are defined above in the expanded
# format so fields can be enabled/disabled.)
# 
# The nec2 coderef must return an NEC2 perl object that defines the entire
# NEC2 geometry:

nec2 => sub {
	use strict;

	my $vars = shift;

	my $nec2 = NEC2->new();
	
	# The Yagi constructor takes the same hash format that
	# is being optimized, but you could do other things with
	# $vars if you like, such as adding NEC2 geometry elements
	# (eg: GW, GH, ...)
	my $yagi = NEC2::Antenna::Yagi->new(%$vars);

	$nec2->add($yagi);

	# Note that the NEC2::Antenna::Yagi class includes
	# an EX card in the center of the 2nd radiated element, so
	# the EX card is not defined here:
	$nec2->add(
		# Free Space:
		GE(ground => 0),
		RP(ground => 0),

		# With ground:
		#GE(ground => 1),
		#GN(type => 1),
		#RP(ground => 1),

		NH,
		NE,
		FR(mhz_min => 134, mhz_max => 155, n_freq => 100)
	);
	
	return $nec2;
},


############################################################################
# Goal Options

# field: the name of the field in the .csv.  
#   Available fields: 
#   	Freq-MHz, Z-real, Z-imag, Z-magn, Z-phase, VSWR, Gain-max, Gain-viewer, F/B Ratio, Direct-tht, Direct-phi
#
#   If field is left undefined, then instead of passing field values to the result function
#   it will pass the current simplex vector and csv so the function can do its
#   own computation.  This could be used to minimize the length of the antenna.
#
# name: an optional field to display the name of the goal
#
# enabled: 1 or 0 to enable/disable.  Not if enable is undefined then it defaults to enabled.
#
# mhz_min: The minimum frequency for which the goal applies
# mhz_max: The maximum frequency for which the goal applies
#
# result: a subroutine (coderef) that is passed a measurement (and frequency) and returns the
#         value that should be minimized.  The result should always return a smaller
#         value when the it is closer to the goal because Simplex works to 
#         find a minima.  The value can be negative.  The frequency being evaluated by the 
#         result function could be used to scale the goal, for example, if the shape of the 
#         goal should vary with frequency.  The name of the variables in the function do not
#         matter, just know that the values being passed are that which is measured from 'field'
#         and the 2nd argument is always the frequency in MHz being evaluated.
#
#         Once all goals are evaulated independantly for each measurement they are summed
#         together.  Thus, it is important the the scale of one goal against another
#         is similar.  If one goal swings the total sum of all goals too much then 
#         the subtle (and possibly important) effects of a different goal will be lost 
#         in the noise of the "louder" goal.  Work could be done here to normalize all
#         goal results against eachother before summing them together.
#
#         For values like VSWR where lower values are better, you can
#         penalize larger values by raising them to a power.  For example:
#            result => sub { my ($swr,$mhz) = @_; return $swr**2; }
#         This forces a flatter SWR curve because higher values are quadratically
#         worse than lower values.
#
#         For values like gain where higher values are better, the value needs to be
#         inverted for simplex.  The simplest way to do this is to make it negative:
#            result => sub { my ($gain,$mhz) = @_; return -$gain; }
#
#         However you may also create a bias by raising it to a fractional power:
#            result => sub { my ($gain,$mhz) = @_; return -$gain*0.5; }
#         A higher power makes the max-gain higher because higher gains get a greater
#         negative score, thus being "better" in terms of how Simplex evaluates it.
#         A lower power makes a flater curve for the opposite reason.
#
#         You can also experiment with creating a synthetic goal and exponentiating
#         the goal as a fraction.  For example:
#            result => sub { my ($gain,$mhz) = @_; return 2**(12/$gain); }
#         This creates a "goal" of 12dB gain such that when the exponent reaches 12/12 it
#         will evaluate as "2".  If gain is less than 12dB it will score exponentially
#         worse.  This also has the effect of normalizing the result against the goal
#         which makes the goals more even (you could also adjust the weights).
#
#         For SWR, invert the fraction so that lower is better:
#            result => sub { my ($swr,$mhz)=@_; return 2**($swr/1.5); }
#
#
#
# type: aggregation type, what to do with of the return from result subroutine for each frequency.
#       avg: add them together and divide by the count
#       min: return the minimum from the set
#            Min will return the "best" value across all frequencies, 
#            so simplex will not work as hard to push it down.
#       max: return the maximum from the set
#            Max will return the "worst" value across all frequencies, 
#            so simplex will work harder to push it down.  Good for VSWR.
#       diff: subtract min from max ($max-$min).
#            This is useful if you want a minimal difference between the two, but the
#            value itself doesn't matter as much.   For example, if you need VSWR to
#            be consistent across the band but the VSWR value doesn't matter because you
#            plan to use an external impedance matching circuit.
#       -diff: sames as diff, but negative.  Useful when you want a large difference 
#            between min and max
#       +diff: alias for 'diff'
#       mag: take the vector magnitude: sum the square of each result and take the sqrt
#       sum: add them together
#            
#       Note that avg/[+-]diff/min/max scale similarly because they represent (approximately) one 
#       single value across all frequencies.  Whereas, "sum" will add all goal results together
#       and increase the result by the number of frequency points.  The "mag" type may work similarly, 
#       but to a lesser degree than sum.  This effect can be adjusted by decreasing the goal weight.
#
# weight: Multiplicative weight, relative scale of the goal.  
#         This weight is multiplied times the result of the aggregation type

goals => [
	{ 
		name => '2m gain',
		field => 'Gain-max',
		enabled => 1,
		mhz_min => 144,
		mhz_max => 148,

		weight => 5,
		
		type => 'avg', 

		# Simplex minimizes, so return a negative value and raise it to a power.
		# A higher power makes the max-gain higher
		# A lower power makes a flater curve
		#
		result => sub { my ($gain,$mhz)=@_; return -$gain**0.5; }
		
		# The (4-(146-$mhz)**2)**2 term attempts to maximize the gain at 146MHz by reducing
		# the multiple as it moves away from center for a narrow-band antenna.
		#result => sub { my ($gain,$mhz)=@_; return -$gain**0.5 * (4-(146-$mhz)**2)**2; }
		
		# This result function exponentiates to the power of the target gain over current gain.
		# It will tend toward a value of 1 as the target is exceeded.
		#result => sub { my ($gain,$mhz)=@_; return 2**(12/$gain); }

		#result => sub { my ($gain,$mhz)=@_; return $gain < 1 ? 100 : (12/$gain); }

	},

	{ 
		name => '2m VSWR',
		field => 'VSWR',
		enabled => 1,
		mhz_min => 144,
		mhz_max => 148,

		# Multiplicative weight, relative scale of the goal
		weight => 5,

		type => 'avg',

		# The optmizer minimizes results, penalize swr quadratically:
		# A larger power provides a flatter SWR
		# A lower power reduces the strength of the SWR penalty.
		result => sub { my ($swr,$mhz)=@_; return 2**$swr; }
         
		# The ((146-$mhz)**2)**2 term attempts to maximize the gain at 146MHz by increasing
		# the multiple as it moves away from center for a narrow-band antenna.
		#result => sub { my ($swr,$mhz)=@_; return $swr**2.0 * ((146-$mhz)**2)**2; }
	},
	{ 
		name => '2m F/B Ratio',
		field => 'F/B Ratio',
		enabled => 1,
		mhz_min => 144,
		mhz_max => 148,

		weight => 1,

		type => 'avg', # calculate minima by sum, avg, min, max, or mag

		#result => sub { my ($fb,$mhz)=@_; return -$fb**1.0; }
		#result => sub { my ($fb,$mhz)=@_; return 2**(20/$fb); }
		result => sub { my ($fb,$mhz)=@_; return (20/$fb); }
	},
	{ 
		name => '70cm gain',
		field => 'Gain-max',
		#field => 'Gain-viewer',
		enabled => 0,
		mhz_min => 430,
		mhz_max => 450,

		weight => 10,
		
		type => 'avg', 

		# Simplex minimizes, so return a negative value and raise it to a power.
		# A higher power makes the max-gain higher
		# A lower power makes a flater curve
		#
		#result => sub { my ($gain,$mhz)=@_; return -$gain**0.5; }
		
		# The (4-(146-$mhz)**2)**2 term attempts to maximize the gain at 146MHz by reducing
		# the multiple as it moves away from center for a narrow-band antenna.
		#result => sub { my ($gain,$mhz)=@_; return -$gain**0.5 * (4-(146-$mhz)**2)**2; }
		
		# This result function exponentiates to the power of the target gain over current gain.
		# It will tend toward a value of 1 as the target is exceeded.
		result => sub { my ($gain,$mhz)=@_; return 2**(12/$gain); }

		#result => sub { my ($gain,$mhz)=@_; return $gain < 1 ? 100 : (12/$gain); }

	},

	{ 
		name => '70cm VSWR',
		field => 'VSWR',
		enabled => 0,
		mhz_min => 430,
		mhz_max => 450,

		# Multiplicative weight, relative scale of the goal
		weight => 10,

		type => 'max',

		# The optmizer minimizes results, penalize swr quadratically:
		# A larger power provides a flatter SWR
		# A lower power reduces the strength of the SWR penalty.
		result => sub { my ($swr,$mhz)=@_; return 2**($swr/0.5); }
         
		# The ((146-$mhz)**2)**2 term attempts to maximize the gain at 146MHz by increasing
		# the multiple as it moves away from center for a narrow-band antenna.
		#result => sub { my ($swr,$mhz)=@_; return $swr**2.0 * ((146-$mhz)**2)**2; }
	},

	{ 
		name => '70cm F/B Ratio',
		field => 'F/B Ratio',
		enabled => 0,
		mhz_min => 430,
		mhz_max => 450,

		weight => 5,

		type => 'avg', # calculate minima by sum, avg, min, max, or mag

		result => sub { my ($fb,$mhz)=@_; return 2**(20/$fb); }
		#result => sub { my ($fb,$mhz)=@_; return (20/$fb); }
	},

	# minimize antenna length
	{ 
		name => 'Antenna Length',
		enabled => 0,
		weight => 10,
		result => sub {
				my ($vars, $csv) = @_;
				my $spaces = $vars->{spaces};
				my ($zoff);

				$zoff += $_ foreach @$spaces;

				return $zoff - $spaces->[0];
			}
	},

	# minimize antenna width
	{ 
		name => 'Antenna Width',
		enabled => 0,
		weight => 10,
		result => sub {
				my ($vars, $csv) = @_;
				my $lengths = $vars->{lengths};
				my $width = 0;
				
				$width = ($_ > $width ? $_ : $width) foreach @$lengths;

				return $width;
			}
	}
]


}; #end of file


