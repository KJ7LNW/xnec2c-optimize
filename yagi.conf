#!/usr/bin/perl

# Reduce the goal frequency range by 5MHz and increase the FR card's range so
# we can see more of the graph than only what is being optimized. This variable
# is not a configuration option, it is used below.
my $mhz_shrink = 5; # MHz

# Keep this line, the whole config is a hash evaluated by do() because
# there are subs in the goal section.
{ 

# See PDL::Opt::Simplex::Simple for documentation on the simplex settings:
simplex => {

	# Initial simplex size: bigger values explore a wider variable range:
	ssize => 0.075,

	# Tolerance: end early if simplex isn't moving much:
	tolerance => 0.01,

	# Max iterations: you may get a more refined result by increasing this:
	max_iter => 200,

	# Seed the random number generator to make this deterministic.
	# Simplex makes use of random perturbation, so if you want to see
	# what random results come after multiple runs, then comment this seed:
	# (Actually this isn't quite as non-deterministic as I would like.)
	'srand' => 4093838779
},

############################################################################
# NEC2 Geometry Variables

# These variables are optimized by simplex.  You can use these variables
# in the the NEC2 geometry function below, in the "nec2" section.

# yagi dimensions from https://www.qsl.net/dk7zb/PVC-Yagis/5-Ele-2m.htm
vars => {
	# Element lengths
	lengths => {
			values  => [ 1.038, 0.955, 0.959, 0.949, 0.935 ],
			enabled => [ 1,     1,     1,     1,     1 ]
		},

	# Spaces between elements:
	spaces => {
			values  => [ 0.000, 0.280, 0.15, 0.520, 0.53 ],
			enabled => [ 0,     1,     1,    1,     1 ]
		},

	wire_rad => {
			values => [ 0.002 ], # 2mm
			enabled => 0,
		},

	# must be odd!
	wire_segments => {
			values => [ 11 ],
			enabled => 0,
		}
},


############################################################################
# NEC2 Geometry

# This function takes a $vars as passed to f() by PDL::Opt::Simplex::Simple
# in the simplified format.  (The vars are defined above in the expanded
# format so fields can be enabled/disabled.)
# 
# The nec2 coderef must return an NEC2 perl object that defines the entire
# NEC2 geometry:

nec2 => sub {
	use strict;

	my $vars = shift;

	my $nec2 = NEC2->new();
	
	# The Yagi constructor takes the same hash format that
	# is being optimized, but you could do other things with
	# $vars if you like, such as adding NEC2 geometry elements
	# (eg: GW, GH, ...)
	my $yagi = NEC2::Antenna::Yagi->new(%$vars);

	$nec2->add($yagi);

	# Note that the NEC2::Antenna::Yagi class includes
	# an EX card in the center of the 2nd radiated element, so
	# the EX card is not defined here:
	$nec2->add(
		# Free Space:
		GE(ground => 0),
		RP(ground => 0),

		# With ground:
		#GE(ground => 1),
		#GN(type => 1),
		#RP(ground => 1),

		NH,
		NE,
		FR(mhz_min => 144-$mhz_shrink, mhz_max => 148+$mhz_shrink, n_freq => 100),
	);
	
	return $nec2;
},

goals => [
	{ 
		name => 'Max gain',
		field => 'Gain-max',
		enabled => 1,

		# Reduce the goal frequency range by 5MHz from the FR card's range so
		# we can see more of the graph than only what is being optimized.
		mhz_shrink => $mhz_shrink,

		weight => 10,
		
		type => 'avg', 

		# Simplex minimizes, so return a negative value and raise it to a power.
		# A higher power makes the max-gain higher
		# A lower power makes a flater curve
		#
		result => sub { my ($gain,$mhz)=@_; return -$gain**0.5; }
		
		# The (4-(146-$mhz)**2)**2 term attempts to maximize the gain at 146MHz by reducing
		# the multiple as it moves away from center for a narrow-band antenna.
		#result => sub { my ($gain,$mhz)=@_; return -$gain**0.5 * (4-(146-$mhz)**2)**2; }
		
		# This result function exponentiates to the power of the target gain over current gain.
		# It will tend toward a value of 1 as the target is exceeded.
		#result => sub { my ($gain,$mhz)=@_; return 2**(12/$gain); }

		#result => sub { my ($gain,$mhz)=@_; return $gain < 1 ? 100 : (12/$gain); }

	},

	{ 
		name => 'VSWR',
		field => 'VSWR',
		enabled => 1,

		mhz_shrink => $mhz_shrink,

		# Multiplicative weight, relative scale of the goal
		weight => 5,

		type => 'avg',

		# The optmizer minimizes results, penalize swr quadratically:
		# A larger power provides a flatter SWR
		# A lower power reduces the strength of the SWR penalty.
		result => sub { my ($swr,$mhz)=@_; return 2**$swr; }
         
		# The ((146-$mhz)**2)**2 term attempts to maximize the gain at 146MHz by increasing
		# the multiple as it moves away from center for a narrow-band antenna.
		#result => sub { my ($swr,$mhz)=@_; return $swr**2.0 * ((146-$mhz)**2)**2; }
	},
	{ 
		name => 'Front/Back Ratio',
		field => 'F/B Ratio',
		enabled => 1,

		mhz_shrink => $mhz_shrink,

		weight => 1,

		type => 'avg', # calculate minima by sum, avg, min, max, or mag

		#result => sub { my ($fb,$mhz)=@_; return -$fb**1.0; }
		#result => sub { my ($fb,$mhz)=@_; return 2**(20/$fb); }
		result => sub { my ($fb,$mhz)=@_; return (20/$fb); }
	},

	# Minimize antenna length.
	#   'field' is undefined, so this function will return a final goal result
	#   independent of all frequencies.
	{ 
		name => 'Antenna Length',
		enabled => 0,
		weight => 10,
		result => sub {
				my ($vars, $csv) = @_;
				my $spaces = $vars->{spaces};
				my ($zoff);

				$zoff += $_ foreach @$spaces;

				return $zoff - $spaces->[0];
			}
	},

	# Minimize antenna width
	#   'field' is undefined, so this function will return a final goal result
	#   independent of all frequencies.
	{ 
		name => 'Antenna Width',
		enabled => 0,
		weight => 10,
		result => sub {
				my ($vars, $csv) = @_;
				my $lengths = $vars->{lengths};
				my $width = 0;
				
				# find max width
				$width = ($_ > $width ? $_ : $width) foreach @$lengths;

				return $width;
			}
	}
]


}; #end of file


